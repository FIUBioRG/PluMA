/********************************************************************************\

                   Plugin-based Microbiome Analysis (PluMA)

        Copyright (C) 2016, 2018-2020, 2026 Bioinformatics Research Group (BioRG)
                       Florida International University


     Permission is hereby granted, free of charge, to any person obtaining
          a copy of this software and associated documentation files
        (the "Software"), to deal in the Software without restriction,
      including without limitation the rights to use, copy, modify, merge,
      publish, distribute, sublicense, and/or sell copies of the Software,
       and to permit persons to whom the Software is furnished to do so,
                    subject to the following conditions:

    The above copyright notice and this permission notice shall be included
            in all copies or substantial portions of the Software.

        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
      TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
           SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

       For information regarding this software, please contact lead architect
                    Trevor Cickovski at tcickovs@fiu.edu

\*********************************************************************************/

#include "JavaPluginGenerator.h"
#include <dirent.h>
#include <cstdlib>
#include <fstream>
#include <iostream>
#include <algorithm>

JavaPluginGenerator::JavaPluginGenerator(std::string path, bool literal) {
    myPath = path;
    myLiteral = literal;
}

void JavaPluginGenerator::generate(std::string pluginname, std::vector<std::string>& command) {
    makeDirectory(pluginname);
    makeJavaFile(pluginname, command);
    makeReadme(pluginname, command);
}

void JavaPluginGenerator::makeDirectory(std::string pluginname) {
    std::string directory = myPath + "/" + pluginname;
    DIR* dir = opendir(directory.c_str());
    if (!dir) {
        system(("mkdir -p " + directory).c_str());
    }
}

void JavaPluginGenerator::makeJavaFile(std::string pluginname, std::vector<std::string>& command) {
    std::string javafile = myPath + "/" + pluginname + "/" + pluginname + "Plugin.java";
    std::ofstream jfile(javafile.c_str(), std::ios::out);

    // Import statements
    jfile << "import java.io.*;" << std::endl;
    jfile << "import java.util.*;" << std::endl;
    jfile << std::endl;

    // Class declaration
    jfile << "/**" << std::endl;
    jfile << " * PluMA plugin: " << pluginname << std::endl;
    jfile << " * Generated by PluGen" << std::endl;
    jfile << " */" << std::endl;
    jfile << "public class " << pluginname << "Plugin {" << std::endl;
    jfile << std::endl;

    // Instance variables
    jfile << "    private String inputFile;" << std::endl;
    jfile << "    private String outputFile;" << std::endl;
    if (!myLiteral) {
        jfile << "    private Map<String, String> parameters = new HashMap<>();" << std::endl;
    }
    jfile << std::endl;

    // Default constructor
    jfile << "    /**" << std::endl;
    jfile << "     * Default constructor required by PluMA" << std::endl;
    jfile << "     */" << std::endl;
    jfile << "    public " << pluginname << "Plugin() {" << std::endl;
    jfile << "    }" << std::endl;
    jfile << std::endl;

    // input method
    jfile << "    /**" << std::endl;
    jfile << "     * Read input parameters from file" << std::endl;
    jfile << "     * @param file Path to the input parameter file" << std::endl;
    jfile << "     */" << std::endl;
    jfile << "    public void input(String file) {" << std::endl;
    jfile << "        this.inputFile = file;" << std::endl;
    if (!myLiteral) {
        jfile << "        // Parse parameter file (tab-delimited key-value pairs)" << std::endl;
        jfile << "        try (BufferedReader reader = new BufferedReader(new FileReader(file))) {" << std::endl;
        jfile << "            String line;" << std::endl;
        jfile << "            while ((line = reader.readLine()) != null) {" << std::endl;
        jfile << "                String[] parts = line.split(\"\\\\t\");" << std::endl;
        jfile << "                if (parts.length >= 2) {" << std::endl;
        jfile << "                    parameters.put(parts[0].trim(), parts[1].trim());" << std::endl;
        jfile << "                }" << std::endl;
        jfile << "            }" << std::endl;
        jfile << "        } catch (IOException e) {" << std::endl;
        jfile << "            System.err.println(\"Error reading parameter file: \" + e.getMessage());" << std::endl;
        jfile << "        }" << std::endl;
    }
    jfile << "    }" << std::endl;
    jfile << std::endl;

    // run method
    jfile << "    /**" << std::endl;
    jfile << "     * Execute the main plugin logic" << std::endl;
    jfile << "     */" << std::endl;
    jfile << "    public void run() {" << std::endl;
    jfile << "        // Main computation goes here" << std::endl;
    jfile << "    }" << std::endl;
    jfile << std::endl;

    // output method
    jfile << "    /**" << std::endl;
    jfile << "     * Write results to output file" << std::endl;
    jfile << "     * @param file Path to the output file" << std::endl;
    jfile << "     */" << std::endl;
    jfile << "    public void output(String file) {" << std::endl;
    jfile << "        this.outputFile = file;" << std::endl;

    // Build command if provided
    if (!command.empty()) {
        jfile << std::endl;
        jfile << "        // Build and execute command" << std::endl;
        jfile << "        StringBuilder cmd = new StringBuilder();" << std::endl;
        jfile << "        cmd.append(\"" << command[0] << "\");" << std::endl;

        bool optionalflag = false;
        for (size_t i = 1; i < command.size(); i++) {
            if (myLiteral && command[i] == "inputfile") {
                jfile << "        cmd.append(\" \").append(inputFile);" << std::endl;
            } else if (command[i] == "outputfile") {
                jfile << "        cmd.append(\" \").append(outputFile);" << std::endl;
            } else if (command[i][0] == '[') {
                optionalflag = true;
            } else if (command[i][0] == ']') {
                optionalflag = false;
            } else if (command[i][0] == '-') {
                if (i + 1 < command.size() && command[i+1] != "inputfile" && command[i+1] != "outputfile") {
                    if (optionalflag) {
                        jfile << "        if (parameters.containsKey(\"" << command[i+1] << "\")) {" << std::endl;
                        jfile << "            cmd.append(\" " << command[i] << " \").append(parameters.get(\"" << command[i+1] << "\"));" << std::endl;
                        jfile << "        }" << std::endl;
                    } else {
                        jfile << "        cmd.append(\" " << command[i] << " \").append(parameters.get(\"" << command[i+1] << "\"));" << std::endl;
                    }
                    i++;
                } else {
                    jfile << "        cmd.append(\" " << command[i] << "\");" << std::endl;
                }
            } else if (!optionalflag) {
                jfile << "        cmd.append(\" \").append(parameters.get(\"" << command[i] << "\"));" << std::endl;
            } else {
                jfile << "        if (parameters.containsKey(\"" << command[i] << "\")) {" << std::endl;
                jfile << "            cmd.append(\" \").append(parameters.get(\"" << command[i] << "\"));" << std::endl;
                jfile << "        }" << std::endl;
            }
        }

        jfile << std::endl;
        jfile << "        // Execute the command" << std::endl;
        jfile << "        try {" << std::endl;
        jfile << "            Process process = Runtime.getRuntime().exec(cmd.toString());" << std::endl;
        jfile << "            int exitCode = process.waitFor();" << std::endl;
        jfile << "            if (exitCode != 0) {" << std::endl;
        jfile << "                System.err.println(\"Command exited with code: \" + exitCode);" << std::endl;
        jfile << "            }" << std::endl;
        jfile << "        } catch (IOException | InterruptedException e) {" << std::endl;
        jfile << "            System.err.println(\"Error executing command: \" + e.getMessage());" << std::endl;
        jfile << "        }" << std::endl;
    }

    jfile << "    }" << std::endl;
    jfile << std::endl;

    // Helper method to get parameter with default
    if (!myLiteral) {
        jfile << "    /**" << std::endl;
        jfile << "     * Get a parameter value with a default fallback" << std::endl;
        jfile << "     * @param key Parameter name" << std::endl;
        jfile << "     * @param defaultValue Default value if parameter not found" << std::endl;
        jfile << "     * @return Parameter value or default" << std::endl;
        jfile << "     */" << std::endl;
        jfile << "    protected String getParameter(String key, String defaultValue) {" << std::endl;
        jfile << "        return parameters.getOrDefault(key, defaultValue);" << std::endl;
        jfile << "    }" << std::endl;
        jfile << std::endl;

        jfile << "    /**" << std::endl;
        jfile << "     * Check if a parameter exists" << std::endl;
        jfile << "     * @param key Parameter name" << std::endl;
        jfile << "     * @return true if parameter exists" << std::endl;
        jfile << "     */" << std::endl;
        jfile << "    protected boolean hasParameter(String key) {" << std::endl;
        jfile << "        return parameters.containsKey(key);" << std::endl;
        jfile << "    }" << std::endl;
        jfile << std::endl;
    }

    // Close class
    jfile << "}" << std::endl;

    jfile.close();
    std::cout << "Generated: " << javafile << std::endl;
}

void JavaPluginGenerator::makeReadme(std::string pluginname, std::vector<std::string>& command) {
    std::string readme = myPath + "/" + pluginname + "/README.md";
    std::ofstream readmefile(readme.c_str(), std::ios::out);

    std::cout << "ENTER OUTPUT FORMAT: ";
    std::string outputfmt;
    std::cin >> outputfmt;

    std::cout << "ENTER DEPENDENCIES: ";
    std::string dependencies;
    std::cin >> dependencies;

    readmefile << "# " << pluginname << std::endl;
    readmefile << std::endl;
    readmefile << "## Overview" << std::endl;
    readmefile << std::endl;
    readmefile << "- **Language:** Java" << std::endl;
    readmefile << "- **Input:** TXT (tab-delimited parameter file)" << std::endl;
    readmefile << "- **Output:** " << outputfmt << std::endl;
    readmefile << "- **Tested with:** PluMA 2.0+, Java 8+" << std::endl;
    if (!dependencies.empty() && dependencies != "none") {
        readmefile << "- **Dependencies:** " << dependencies << std::endl;
    }
    readmefile << std::endl;

    readmefile << "## Description" << std::endl;
    readmefile << std::endl;
    readmefile << "PluMA plugin that runs " << pluginname << "." << std::endl;
    readmefile << std::endl;

    readmefile << "## Parameters" << std::endl;
    readmefile << std::endl;
    readmefile << "The plugin expects a parameter file with tab-delimited keyword-value pairs:" << std::endl;
    readmefile << std::endl;

    bool optionalflag = false;
    for (size_t i = 1; i < command.size(); i++) {
        if (command[i][0] == '[') {
            optionalflag = true;
        } else if (command[i][0] == ']') {
            optionalflag = false;
        } else if (command[i][0] == '-') {
            if (i + 1 < command.size() && command[i+1] != "inputfile" && command[i+1] != "outputfile") {
                if (optionalflag) {
                    readmefile << "- `" << command[i+1] << "` (optional, flag: " << command[i] << ")" << std::endl;
                } else {
                    readmefile << "- `" << command[i+1] << "` (required, flag: " << command[i] << ")" << std::endl;
                }
                i++;
            }
        } else if (command[i] != "inputfile" && command[i] != "outputfile") {
            if (optionalflag) {
                readmefile << "- `" << command[i] << "` (optional)" << std::endl;
            } else {
                readmefile << "- `" << command[i] << "` (required)" << std::endl;
            }
        }
    }

    readmefile << std::endl;
    readmefile << "## Building" << std::endl;
    readmefile << std::endl;
    readmefile << "Compile the plugin with:" << std::endl;
    readmefile << std::endl;
    readmefile << "```bash" << std::endl;
    readmefile << "javac " << pluginname << "Plugin.java" << std::endl;
    readmefile << "```" << std::endl;
    readmefile << std::endl;

    readmefile << "## Usage" << std::endl;
    readmefile << std::endl;
    readmefile << "In your PluMA pipeline file:" << std::endl;
    readmefile << std::endl;
    readmefile << "```" << std::endl;
    readmefile << "Plugin " << pluginname << " inputfile params.txt outputfile output." << outputfmt << std::endl;
    readmefile << "```" << std::endl;

    readmefile.close();
    std::cout << "Generated: " << readme << std::endl;
}
